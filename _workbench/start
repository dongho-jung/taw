#!/bin/bash

PROJECT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_NAME="$(basename "$PROJECT_DIR")"
WORKBENCH_DIR="$(cd "$PROJECT_DIR/../.." && pwd)/_workbench"
WATCHER_DIR="$PROJECT_DIR/.watcher"
SESSION_NAME="$PROJECT_NAME"

GLOBAL_PROMPT="$WORKBENCH_DIR/PROMPT.md"
PROJECT_PROMPT="$PROJECT_DIR/PROMPT.md"

json_escape() {
    local str="$1"
    str="${str//\\/\\\\}"
    str="${str//\"/\\\"}"
    str="${str//$'\n'/\\n}"
    str="${str//$'\r'/\\r}"
    str="${str//$'\t'/\\t}"
    echo "$str"
}

check_dependencies() {
    if ! command -v zellij &> /dev/null; then
        echo "zellij is not installed. Install: brew install zellij"
        exit 1
    fi
    if ! command -v fswatch &> /dev/null; then
        echo "fswatch is not installed. Install: brew install fswatch"
        exit 1
    fi
}

is_session_running() {
    zellij list-sessions 2>/dev/null | grep -q "$SESSION_NAME"
}

zj() {
    zellij --session "$SESSION_NAME" action "$@"
}

cleanup() {
    echo "Cleaning up..."
    pkill -f "fswatch.*$PROJECT_DIR" 2>/dev/null
    rm -f "$WATCHER_DIR/watcher.pid"
}

start_session() {
    check_dependencies

    # Create watcher directory first
    mkdir -p "$WATCHER_DIR"
    touch "$WATCHER_DIR/watcher.log"

    echo "Starting session '$SESSION_NAME'..."

    # Start watcher in background first
    start_watcher &
    local watcher_pid=$!
    echo "$watcher_pid" > "$WATCHER_DIR/watcher.pid"

    # Cleanup on exit
    trap cleanup EXIT

    # Start zellij session with layout (tab name "_", cwd = PROJECT_DIR)
    cd "$PROJECT_DIR"
    zellij -s "$SESSION_NAME" -n "$WORKBENCH_DIR/layout.kdl"

    # This runs after zellij exits
    cleanup
}

get_status_from_path() {
    local path="$1"
    if [[ "$path" == to-do/* ]]; then echo "to-do"
    elif [[ "$path" == in-progress/* ]]; then echo "in-progress"
    elif [[ "$path" == in-review/* ]]; then echo "in-review"
    elif [[ "$path" == done/* ]]; then echo "done"
    elif [[ "$path" == cancelled/* ]]; then echo "cancelled"
    else echo ""
    fi
}

get_task_name_from_path() {
    local path="$1"
    local filename=$(basename "$path")
    echo "${filename%.*}"  # Remove extension
}

handle_task_event() {
    local relative_path="$1"
    local event_flags="$2"
    local file_content="$3"

    local status=$(get_status_from_path "$relative_path")
    if [ -z "$status" ]; then
        return
    fi

    local task_name=$(get_task_name_from_path "$relative_path")
    local agent_dir="$PROJECT_DIR/agents/$task_name"
    local tab_name="$task_name/$status"
    local task_file="$PROJECT_DIR/$relative_path"

    # Create agent directory
    mkdir -p "$agent_dir"

    # Save task info to JSON file
    cat > "$agent_dir/task.json" << TASKJSON
{
  "path": "$relative_path",
  "event": "$event_flags",
  "status": "$status",
  "task_file": "$task_file"
}
TASKJSON

    # Log
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Task: $task_name, Status: $status" >> "$agent_dir/log"

    # Try to find existing tab for this task (any status)
    local found_tab=""
    for old_status in "to-do" "in-progress" "in-review" "done" "cancelled"; do
        local old_tab_name="$task_name/$old_status"
        if zj go-to-tab-name "$old_tab_name" 2>/dev/null; then
            found_tab="$old_tab_name"
            break
        fi
    done

    if [ -n "$found_tab" ]; then
        # Tab exists - just rename it
        zj rename-tab "$tab_name"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] Renamed tab: $found_tab -> $tab_name" >> "$WATCHER_DIR/watcher.log"
        return
    fi

    # No existing tab - create new one with claude

    # Build system prompt from global and project PROMPT files
    local system_prompt=""
    if [ -f "$GLOBAL_PROMPT" ]; then
        system_prompt=$(cat "$GLOBAL_PROMPT")
    fi
    if [ -f "$PROJECT_PROMPT" ]; then
        if [ -n "$system_prompt" ]; then
            system_prompt="$system_prompt"$'\n\n---\n\n'
        fi
        system_prompt="$system_prompt$(cat "$PROJECT_PROMPT")"
    fi

    # Read task content (only the part above the separator '----------')
    local task_content=""
    if [ -f "$task_file" ]; then
        # Extract content above the separator (10 hyphens)
        task_content=$(sed -n '/^----------$/q;p' "$task_file")
    fi

    # Build the user prompt with task context
    local user_prompt="# Task Execution Request

## Task Info
- **Name**: $task_name
- **Status**: $status
- **Path**: $relative_path
- **Task File**: $task_file

## Task Content
$task_content

## Instructions
1. Execute this task following the system instructions
2. Log your progress to agents/$task_name/log
3. When done, write your result summary to the task file below the separator line (\`----------\`)
4. Move the task file to done/ (or in-review/ if human review needed)"

    # Save system prompt to file for claude to use
    echo "$system_prompt" > "$agent_dir/system-prompt.txt"

    # Save user prompt to file
    echo "$user_prompt" > "$agent_dir/user-prompt.txt"

    # Create new tab with task name/status (cwd = PROJECT_DIR)
    zj new-tab --name "$tab_name" --cwd "$PROJECT_DIR"
    sleep 0.5

    # Split vertically (creates right pane, left has claude)
    zj new-pane --direction right

    # Go back to left pane (focus left)
    zj move-focus left

    # Helper to send text + Enter
    send_line() {
        zj write-chars "$1"
        sleep 0.1
        zj write-chars $'\n'
    }

    # Start claude interactively with system prompt
    send_line "claude --dangerously-skip-permissions --system-prompt \"\$(cat agents/$task_name/system-prompt.txt)\""

    # Wait for claude to start
    sleep 2

    # Check if confirmation is needed by examining screen content
    local screen_content
    screen_content=$(zellij --session "$SESSION_NAME" action dump-screen 2>/dev/null || echo "")
    if echo "$screen_content" | grep -qiE "trust|Trust this project|y/n|\[y\]|Are you sure"; then
        send_line "y"
        sleep 1
    fi

    # Send the task instruction (use absolute path)
    send_line "Read and execute the task from $agent_dir/user-prompt.txt"

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Created tab: $tab_name, sent task to claude" >> "$WATCHER_DIR/watcher.log"
}

start_watcher() {
    # Wait for session to start
    for i in {1..30}; do
        if is_session_running; then
            break
        fi
        sleep 0.5
    done

    echo "[$(date '+%Y-%m-%d %H:%M:%S')] Watcher started" >> "$WATCHER_DIR/watcher.log"

    fswatch -x --exclude "location" --exclude ".watcher" --exclude "agents" --exclude "start" --exclude "metadata" --exclude "PROMPT.md" -r "$PROJECT_DIR" 2>/dev/null | while read -r line; do
        changed_file=$(echo "$line" | awk '{print $1}')
        event_flags=$(echo "$line" | cut -d' ' -f2-)

        # Skip unwanted paths
        if [[ "$changed_file" == "$PROJECT_DIR/location"* ]]; then continue; fi
        if [[ "$changed_file" == "$PROJECT_DIR/agents"* ]]; then continue; fi
        if [[ "$changed_file" == "$PROJECT_DIR/.watcher"* ]]; then continue; fi

        if ! is_session_running; then
            echo "[$(date '+%Y-%m-%d %H:%M:%S')] Session not running, stopping" >> "$WATCHER_DIR/watcher.log"
            break
        fi

        relative_path="${changed_file#$PROJECT_DIR/}"
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] File: $relative_path ($event_flags)" >> "$WATCHER_DIR/watcher.log"

        file_content=""
        if [ -f "$changed_file" ]; then
            file_content=$(cat "$changed_file")
        fi

        handle_task_event "$relative_path" "$event_flags" "$file_content"
    done
}

# Kill existing session and start fresh
if is_session_running; then
    echo "Killing existing session '$SESSION_NAME'..."
    zellij kill-session "$SESSION_NAME" 2>&1 >/dev/null
    pkill -f "fswatch.*$PROJECT_DIR" 2>/dev/null
    rm -f "$WATCHER_DIR/watcher.pid"

    # Wait until session is fully terminated
    for i in {1..20}; do
        if ! is_session_running; then
            break
        fi
        sleep 0.2
    done

    # Force kill if still running
    if is_session_running; then
        echo "Force killing session..."
        zellij delete-session "$SESSION_NAME" --force 2>&1 >/dev/null
        sleep 0.5
    fi
fi
start_session
